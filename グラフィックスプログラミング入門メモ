グラフィックスプログラミング入門

2-1
関数には文と、式がある。
【文】
function BUN(){
    console.log('関数宣言文');
}
【式】
let SHIKI = function(){     ←無名関数という
    console.log('関数式');
};

呼び出しはSHIKI(引数); でおっけー

【アロー関数】
関数定義の方法の一つ、関数式として扱われる→変数に代入する感じ→戻り値があるやつなら他の関数の引数に取ることができる。

let arrow = () =>{
    console.log('アロー関数');
};

【コールバック関数】
関数の中で一通り処理が終わった後に呼び出される関数（？？？？？あんまりよくわかってない）

onClickとかonSubmitのことかな？？？
イベント駆動型言語

オブジェクト（でたよ）
めちゃめちゃざっくり、プロパティあるいはメソッドの集合体
プロパティ→Beansのイメージ、いろんなデータのこと（Userっていうオブジェクトのnameとか、ageとか……）
メソッド→オブジェクトのもつ関数のこと

ビルトインオブジェクト、プロトタイプチェーン→もともとあるやつ、とりあえずこれだけ

条件式とか演算子とかはまあまあまあ……

【今回のシューティングゲームに必要なもの】

・縦スクロール型（上下に動かしながら進めて行く）
・地形効果なし
・キーボード操作であること
・ループ機能
・スコアの集計
・敵の登場パターン
・gameover演出、リスタート

【クラスベースとプロトタイプベースの違い】
・クラスベースの言語（javaやC言語）では、クラスが設計図、インスタンスはその実体（クラス→ロボットの設計図（機能とかが書いてある）  インスタンス→ロボット）
・プロトタイプベース（javascriptなど）はクラスとインスタンスという区分がそもそも存在せず、全てのオブジェクトはプロトタイプを持つ。
・プロトタイプベースの言語では、オブジェクトが（プロトタイプごと一緒に）複製されて、新しいインスタンスになる。
・同じプロトタイプを持つオブジェクトは、同じメソッドやプロパティを持つ。


オブジェクトのプロトタイプを設定するには、prototypeを利用する

let Robot = () =>{};//関数オブジェクト←これのことをコンストラクタ関数という（コンストラクタ関数を持つオブジェクト、Robotのように、大文字からスタートする）

Robot.prototype.size=100;
Robot.prototype.weight=10;

Robot.prototype.walk= () =>{
    console.log('歩いてます');   
}

オブジェクト名.prototype.メソッドorプロパティ名

クラス構文とは？？？→ちょうど今やってる、クラスコンポーネントみたいな書き方

class Robot{
    constructor(){
        this.size=100;
        this.weight=10;
    }
    walk(){
        console.log('歩いてます');
    }

}

↑プロパティ(オブジェクトが持つ属性値)を、constructorとかいう謎の関数の中で初期化、定義している
メソッドは名前を直接書き込む（let,constとかは、いらん）

constructor関数は特殊なもので、new演算子と共に呼び出される。新しいインスタンスを生成するたびに必ず呼び出される関数
プロパティの定義
this.任意のプロパティ名 = 値;
ゲームキャラの位置情報を示す座標情報や、生きてるか死んでるかを表すboolean型の値などなど

プロトタイプは拡張できる！クラスベースでは、インスタンスはあくまで設計図であるクラスに記載されていることに従って振る舞う常に静的なもの
ただし、ビルとインオブジェクト（javascriptに最初っから備わっているArray,Math,Mapなどのオブジェクト）をこっちが拡張すると、正常に動かなくなる可能性があるので、推奨されない。


getterとsetter javabeansで作ったあれのイメージでとりあえずはおっけい
冗長な名前のプロパティも簡単に参照できるようになる

メソッド→オブジェクトの持つ関数のこと、class構文ではメソッドを定義する場合でも、ClassName.prototype.methodNameのように、protptypeを利用する必要はなく、
メソッド名の記述だけでそのクラスの持つメソッドを定義できる。

→つまり？？？？？？？

class Yamamoto{
    コンストラクター（略）

    greeting(){  //←constとかletとかいらない
        console.log('こんちわ');
    }
}

プロトタイプチェーン？？？？？？？？
プロトタイプを使うメリット

１．プロトタイプをつかわないパターン
function Robot(){
    this.name='David';

    this.sayName = () =>{
        console.log('this.name');
    };   
}

let r = new Robot();
    r.sayName(); //Davidと出力


後からプロパティを追加する場合……
function Robot(){
    this.name='David';

    this.sayName = () =>{
        console.log(this.name);
    };
}

let r = new Robot();
r.sayName();

//Robotに新しいプロパティを追加
Robot.size = 10;


console.log(r.size); //→undifined  ※追加前に生成されていたインスタンスなので影響は受けない。


でももし、Robotクラスが、sizeというプロパティを持っているMachineクラスのプロトタイプを持っていたら？？？
r.sizeっていう参照をした時に、まずRobotオブジェクトのなかで、そのプロパティなりメソッドを探した後、ないわってなったら、
そのプロトタイプとなったオブジェクトMachineから探す、もしまたないわってなったら、さらにそのプロトタイプとなったオブジェクトから探して…って感じに同名のプロパティなりメソッドが
見つかるまで遡ってくれる。

→これをプロトタイプチェーンという！！（javaの継承とかの考え方と似てるのかな？？？）


つまりはどんな時にこの仕組みを使うといいか

→再利用回数が高く、何回もインスタンスを新しく作るようなオブジェクトを扱う場合
なんか、メモリとかの消費が少なく済んで、エコらしい
使ったことによるデメリットも特にないし、できれば使って行きたいよね、くらい

002  メインループ
タイムスタンプ→現刻の経過を整数で表したものstartTime変数に格納

window.addEventListener('load', () =>{   //←ページのロード完了時に発火するloadイベント
    //(略)
    
    //画像の読み込み処理
    util.imageLoader('./image/viper.png', (loadedImage) =>{
        image = loadedImage;
        initialize(); //初期化
        //実効開始時のタイムスタンプを取得
        startTime = Date.now();
        render();
    });
},false);


render関数(描画処理を行う関数)
最初にcanvas要素内全体をグレーで塗りつぶす処理を行なっている
イメージとしては…
初期位置→方向キーの打ち込み→再度全体の塗りつぶし→キャラクター位置が変わったものの描画→打ち込み→塗りつぶし……って感じで
いかにもアニメーションっぽくしている
最初の塗りつぶし処理がないとキャラクターが重なって次々に描写されていくからアニメ感がなくなっちゃう

計測した経過時間をMath.sinの引数として与える
時間の経過をラジアンで表している

requestAnimationFrame(render)

ディスプレイのリフレッシュレートに応じて、自動的に繰り返しの描画処理を呼び出してくれる関数
引数にrender関数を取っている

一般的には1秒間に60回画面を更新(1フレーム=1/60s のアレ)

003
ユーザーの入力を受け付けられるようにする
ユーザーのインタラクティブな操作を受け取るための仕組みを作るにはaddEventListenerを利用する。
keydown→キーが押された時（shiftを押しても発生）
keypress→キーが押された時（siftが押されてたら発生しない）
keydown→キーを離した時

通常、ゲームをjsで作る場合、keydownとkeyupを使うと良い

viperX、viperY→それぞれ操作キャラのX座標とY座標を表す
window.addEventListener(keydown, (event) =>{

},false)  でwindow全体でキーの入力を検出

keydownによって呼ばれる関数（第二引数になってるやつ）をコールバック関数という

コールバック関数の中では、eventという変数を利用し、処理を行っている
引数eventにはKeyBoardEventというオブジェクトが渡されてくる。このkeyプロパティを参照すると、イベント発生のトリガーとなったキーの種類を文字列で取得できる。


矢印キーはArrowキーと言われているため、→キーはArrowRight
キーの入力があったらViperX,Yをそれぞれ変化させるようにしている。


