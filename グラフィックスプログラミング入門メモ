グラフィックスプログラミング入門

2-1
関数には文と、式がある。
【文】
function BUN(){
    console.log('関数宣言文');
}
【式】
let SHIKI = function(){     ←無名関数という
    console.log('関数式');
};

呼び出しはSHIKI(引数); でおっけー

【アロー関数】
関数定義の方法の一つ、関数式として扱われる→変数に代入する感じ→戻り値があるやつなら他の関数の引数に取ることができる。

let arrow = () =>{
    console.log('アロー関数');
};

【コールバック関数】
関数の中で一通り処理が終わった後に呼び出される関数（？？？？？あんまりよくわかってない）

onClickとかonSubmitのことかな？？？
イベント駆動型言語

オブジェクト（でたよ）
めちゃめちゃざっくり、プロパティあるいはメソッドの集合体
プロパティ→Beansのイメージ、いろんなデータのこと（Userっていうオブジェクトのnameとか、ageとか……）
メソッド→オブジェクトのもつ関数のこと

ビルトインオブジェクト、プロトタイプチェーン→もともとあるやつ、とりあえずこれだけ

条件式とか演算子とかはまあまあまあ……

【今回のシューティングゲームに必要なもの】

・縦スクロール型（上下に動かしながら進めて行く）
・地形効果なし
・キーボード操作であること
・ループ機能
・スコアの集計
・敵の登場パターン
・gameover演出、リスタート

【クラスベースとプロトタイプベースの違い】
・クラスベースの言語（javaやC言語）では、クラスが設計図、インスタンスはその実体（クラス→ロボットの設計図（機能とかが書いてある）  インスタンス→ロボット）
・プロトタイプベース（javascriptなど）はクラスとインスタンスという区分がそもそも存在せず、全てのオブジェクトはプロトタイプを持つ。
・プロトタイプベースの言語では、オブジェクトが（プロトタイプごと一緒に）複製されて、新しいインスタンスになる。
・同じプロトタイプを持つオブジェクトは、同じメソッドやプロパティを持つ。


オブジェクトのプロトタイプを設定するには、prototypeを利用する

let Robot = () =>{};//関数オブジェクト←これのことをコンストラクタ関数という（コンストラクタ関数を持つオブジェクト、Robotのように、大文字からスタートする）

Robot.prototype.size=100;
Robot.prototype.weight=10;

Robot.prototype.walk= () =>{
    console.log('歩いてます');   
}

オブジェクト名.prototype.メソッドorプロパティ名

クラス構文とは？？？→ちょうど今やってる、クラスコンポーネントみたいな書き方

class Robot{
    constructor(){
        this.size=100;
        this.weight=10;
    }
    walk(){
        console.log('歩いてます');
    }

}

↑プロパティ(オブジェクトが持つ属性値)を、constructorとかいう謎の関数の中で初期化、定義している
メソッドは名前を直接書き込む（let,constとかは、いらん）

constructor関数は特殊なもので、new演算子と共に呼び出される。新しいインスタンスを生成するたびに必ず呼び出される関数
プロパティの定義
this.任意のプロパティ名 = 値;
ゲームキャラの位置情報を示す座標情報や、生きてるか死んでるかを表すboolean型の値などなど

プロトタイプは拡張できる！クラスベースでは、インスタンスはあくまで設計図であるクラスに記載されていることに従って振る舞う常に静的なもの
ただし、ビルとインオブジェクト（javascriptに最初っから備わっているArray,Math,Mapなどのオブジェクト）をこっちが拡張すると、正常に動かなくなる可能性があるので、推奨されない。


getterとsetter javabeansで作ったあれのイメージでとりあえずはおっけい
冗長な名前のプロパティも簡単に参照できるようになる

メソッド→オブジェクトの持つ関数のこと、class構文ではメソッドを定義する場合でも、ClassName.prototype.methodNameのように、protptypeを利用する必要はなく、
メソッド名の記述だけでそのクラスの持つメソッドを定義できる。

→つまり？？？？？？？

class Yamamoto{
    コンストラクター（略）

    greeting(){  //←constとかletとかいらない
        console.log('こんちわ');
    }
}

プロトタイプチェーン？？？？？？？？
プロトタイプを使うメリット

１．プロトタイプをつかわないパターン
function Robot(){
    this.name='David';

    this.sayName = () =>{
        console.log('this.name');
    };   
}

let r = new Robot();
    r.sayName(); //Davidと出力


後からプロパティを追加する場合……
function Robot(){
    this.name='David';

    this.sayName = () =>{
        console.log(this.name);
    };
}

let r = new Robot();
r.sayName();

//Robotに新しいプロパティを追加
Robot.size = 10;


console.log(r.size); //→undifined  ※追加前に生成されていたインスタンスなので影響は受けない。


でももし、Robotクラスが、sizeというプロパティを持っているMachineクラスのプロトタイプを持っていたら？？？
r.sizeっていう参照をした時に、まずRobotオブジェクトのなかで、そのプロパティなりメソッドを探した後、ないわってなったら、
そのプロトタイプとなったオブジェクトMachineから探す、もしまたないわってなったら、さらにそのプロトタイプとなったオブジェクトから探して…って感じに同名のプロパティなりメソッドが
見つかるまで遡ってくれる。

→これをプロトタイプチェーンという！！（javaの継承とかの考え方と似てるのかな？？？）


つまりはどんな時にこの仕組みを使うといいか

→再利用回数が高く、何回もインスタンスを新しく作るようなオブジェクトを扱う場合
なんか、メモリとかの消費が少なく済んで、エコらしい
使ったことによるデメリットも特にないし、できれば使って行きたいよね、くらい

